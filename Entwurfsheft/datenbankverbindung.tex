\section{Datenbankverbindung}

\subsection{Datenbankaufbau}
Die Datenbank beinhaltet folgende Tabellen:

\paragraph{}
\begin{tabular}{|p{4cm}|p{2cm}|p{6cm}|}
	\hline
	\textbf{Server} &  & \\
	\hline
	name & String & $key; notNull$ \\
	\hline
	adress & String & $notNull$\\
	\hline
	containerlimit & int & $notNull$\\
	\hline
\end{tabular}

\paragraph{}
\begin{tabular}{|p{4cm}|p{2cm}|p{6cm}|}
	\hline
	\textbf{Workflow\_Template} &  & \\
	\hline
	name & String & $key; notNull$ \\
	\hline
	dag & .py -File & $notNull$\\
	\hline
\end{tabular}

\paragraph{}
\begin{tabular}{|p{4cm}|p{2cm}|p{6cm}|}
	\hline
	\textbf{Workflow} &  & \\
	\hline
	name & String & $key; notNull$ \\
	\hline
	files & String & $notNull$ \\
	\hline
	dag & .py  -File & $notNull$\\
	\hline
\end{tabular}

\paragraph{}
\begin{tabular}{|p{4cm}|p{2cm}|p{6cm}|}
	\hline
	\textbf{Version} & & \\
	\hline
	wfName & String & $key; notNull;$ name from Workflow\\
	\hline
	version & String & $key; notNull$ \\
	\hline
\end{tabular}

\paragraph{}
\begin{tabular}{|p{4cm}|p{2cm}|p{6cm}|}
	\hline
	\textbf{ActiveVersion} & & \\
	\hline
	wfName & String & $key; notNull;$ name from Workflow\\
	\hline
	version & String & $notNull;$ from Version\\
	\hline
\end{tabular}

\paragraph{}
\begin{tabular}{|p{4cm}|p{2cm}|p{6cm}|}
	\hline
	\textbf{VersionFile} & & \\
	\hline
	wfName & String & $key; notNull;$ name from Workflow\\
	\hline
	version & String & $key; notNull;$ from Version \\
	\hline
	confKey & String & $key; notNull;$ from ConfFiles \\
	\hline
\end{tabular}

\paragraph{}
\begin{tabular}{|p{4cm}|p{2cm}|p{6cm}|}
	\hline
	\textbf{ConfFile} & & \\
	\hline
	confKey & String & $key; notNull$ \\
	\hline
	file & .conf -File & $notNull$ \\
	\hline
\end{tabular}

\paragraph{Note}While the dag-file could be used as a key between Workflow\_Template and Workflow, it is not efficient to traverse over. On creation of a new Workflow, the based Template dag-file will be copied.


% vv Neu schreiben vv
\subsection{Database Package}

Hier Package png und Erklärung

\subsubsection{Class.DatabaseTable}
DatabaseTable ist die einzige Klasse die direkt mit der Datenbank kommuniziert. Ihre Funktion ist hauptsächlich MySQL Befehle entgegennimmt, diese an die Datenbank weitergibt und die dadurch erhaltenen Antworten zurückgibt.

\paragraph{set(create: String):String} Erstelle neuen Eintrag. Versuche $create$ auf MySQL auszuführen und gib die Antwort als String zurück.

\paragraph{delete(del: String):String} Lösche einen existierenden Eintrag. Versuche $del$ auf MySQL auszuführen und gib die Antwort als String zurück.

\paragraph{modify(change: String):String} Ändere einen existierenden Eintrag. Versuche $change$ auf MySQL auszuführen und gib die Antwort als String zurück.


























\newpage